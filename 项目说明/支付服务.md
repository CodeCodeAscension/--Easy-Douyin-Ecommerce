# 支付服务逻辑说明

订单和支付的逻辑：首先用户根据购物车选中的商品信息调用订单服务创建order并返回，此时order状态为待确认，这里可以设置过时自动取消。等待前端用户确认之后将orderId和所使用的银行卡id传给支付服务，此时发送pay.start消息到mq中，让order的状态变为已确认待支付。此时支付服务生成一个预支付ID，将信息返回给前端，这个时候也可以设置过时自动取消，取消则发送pay.cancel消息给order服务。用户确认之后就去执行真正的支付过程，在订单服务里使用openfeign调用商品服务减少库存，如果库存不足则标记支付失败发送pay.cancel消息返回，库存充足则减少商品库存。从银行卡里扣钱可以自定义一个工具类来实现，如果余额不足则发送pay.fail消息让商品服务恢复库存数量同时标记order订单为失败。支付成功后向消息队列发送pay.success消息，让商品服务增加销量同时标记order订单为已支付。

本地的rabbitmq服务需要创建名为directExchange的DirectExchange，以及四个FanoutExchange，名为pay.start，pay.cancel，pay.success，pay.fail，这些Fanout绑定的队列则以Fanout名为前缀的若干微服务所使用的队列，比如`pay.fail.order`，`pay.success.product`等。RoutingKey则分别为队列的名字。此外，还需要导入配置：

```yml
ecommerce:
 rabbitmq:
  exchange-name: "directExchange"
  queues:
   pay:
    start: "pay.start"
    cancel: "pay.cancel"
    fail: "pay.fail"
    success: "pay.success"
```

到nacos（命名为mq-queues-config.yaml）或者自己的微服务的application.yml里。这样就可以直接使用com.example.common.config.rabbitmq.RabbitQueuesConfig对象的值代替字符串操作

一、

支付服务接收到订单支付信息，产生预支付交易记录（需不需要预扣款？）

返回预支付ID给前端，同时向订单服务发送支付启动消息（此时preCharge方法结束）

二、

用户点击确认支付，前端返回预支付id给支付服务，支付服务确认支付，并进行扣款（如进行预扣款则跳过该步骤），向订单服务发送支付成功（失败）消息，返回成功（失败）消息给前端（Charge方法结束）

三、

用户点击取消支付，前端返回预支付id给支付服务，取消已存在的定时取消任务，预订单逻辑删除，并向订单服务发送取消支付消息，返回成功给前端

四、

用户定时取消支付，前端返回请求体（包含预支付id）给支付服务，定时执行取消支付方法，以及根据需要选择是否重置定时任务（定时任务如何保存，如何获取上一次定的时间？）